# StopShorts ç¿’æ…£åŒ–ã‚³ãƒ¼ãƒãƒ³ã‚°æ©Ÿèƒ½ è¨­è¨ˆæ›¸ v3.0

> **ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦**
> ã‚·ãƒ§ãƒ¼ãƒˆå‹•ç”»ã®è¦–è´ç¿’æ…£ã‚’æ–­ã¡åˆ‡ã‚‹ãŸã‚ã®ã€Œç¿’æ…£åŒ–ã‚³ãƒ¼ãƒãƒ³ã‚°æ©Ÿèƒ½ã€ã¨ã€Œçµ±è¨ˆæ©Ÿèƒ½ã€ã®è¨­è¨ˆæ›¸ã§ã™ã€‚
> è¡Œå‹•ç§‘å­¦ãƒ»å¿ƒç†å­¦ã®ç ”ç©¶ã«åŸºã¥ã„ãŸè¨­è¨ˆã¨ã€è©³ç´°ãªå®Ÿè£…è¨ˆç”»ã‚’è¨˜è¿°ã—ã¾ã™ã€‚

---

## ç›®æ¬¡

1. [æ¦‚è¦](#æ¦‚è¦)
2. [å¿ƒç†å­¦çš„åŸºç›¤](#å¿ƒç†å­¦çš„åŸºç›¤)
3. [ç¿’æ…£å½¢æˆã®æ ¸å¿ƒæ‰‹æ³•](#ç¿’æ…£å½¢æˆã®æ ¸å¿ƒæ‰‹æ³•)
4. [ã‚³ã‚¢æ©Ÿèƒ½è¨­è¨ˆ](#ã‚³ã‚¢æ©Ÿèƒ½è¨­è¨ˆ)
5. [çµ±è¨ˆãƒ»åˆ†ææ©Ÿèƒ½](#çµ±è¨ˆåˆ†ææ©Ÿèƒ½)
6. [ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³](#ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³)
7. [æŠ€è¡“çš„å®Ÿè£…è¦ä»¶](#æŠ€è¡“çš„å®Ÿè£…è¦ä»¶)
8. [è©³ç´°å®Ÿè£…è¨ˆç”»](#è©³ç´°å®Ÿè£…è¨ˆç”»)
9. [èª²é‡‘ãƒ¢ãƒ‡ãƒ«](#èª²é‡‘ãƒ¢ãƒ‡ãƒ«)
10. [å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—](#å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—)

---

## æ¦‚è¦

### ç›®çš„
ã‚·ãƒ§ãƒ¼ãƒˆå‹•ç”»ã‚¢ãƒ—ãƒªï¼ˆTikTokã€YouTube Shortsã€Instagram Reelsï¼‰ã‚’**ç„¡æ„è­˜ã«é–‹ãç¿’æ…£**ã‚’æ–­ã¡åˆ‡ã‚Šã€**æ„è­˜çš„ãªé¸æŠ**ã«å¤‰ãˆã‚‹ã€‚

### è¨­è¨ˆæ€æƒ³
1. **å®Œå…¨ãƒ–ãƒ­ãƒƒã‚¯ã§ã¯ãªãã€Œæ„è­˜åŒ–ã€** - ä½¿ç”¨ã‚’ç¦æ­¢ã™ã‚‹ã®ã§ã¯ãªãã€ä½¿ã†å‰ã«ç«‹ã¡æ­¢ã¾ã‚‰ã›ã‚‹
2. **ç§‘å­¦çš„æ ¹æ‹ ã«åŸºã¥ãè¨­è¨ˆ** - è¡Œå‹•å¤‰å®¹ç†è«–ã‚’æ´»ç”¨
3. **èƒ½å‹•çš„ãªç¿’æ…£å½¢æˆ** - å—å‹•çš„ãªä»‹å…¥ã ã‘ã§ãªãã€è‡ªã‚‰ç·´ç¿’ã™ã‚‹ä»•çµ„ã¿
4. **å¯è¦–åŒ–ã«ã‚ˆã‚‹è‡ªå·±åŠ¹åŠ›æ„Ÿ** - ãƒ‡ãƒ¼ã‚¿ã§æˆé•·ã‚’å®Ÿæ„Ÿ

### ç«¶åˆåˆ†æ: one secã‚¢ãƒ—ãƒª

#### one secã®å„ªã‚Œã¦ã„ã‚‹ç‚¹

| è¦ç´  | èª¬æ˜ | å¿ƒç†å­¦çš„æ ¹æ‹  |
|------|------|-------------|
| **æ„å›³çš„ãªæ‘©æ“¦** | ã‚¢ãƒ—ãƒªèµ·å‹•ã‚’é…å»¶ã•ã›ã‚‹ | è‡ªå‹•çš„ãªè¡Œå‹•ã‚’ä¸­æ–­ã—å†è€ƒã®æ©Ÿä¼šã‚’ä¸ãˆã‚‹ |
| **æ·±å‘¼å¸ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹** | 5-10ç§’ã®å‘¼å¸ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ | ã‚·ã‚¹ãƒ†ãƒ 1â†’ã‚·ã‚¹ãƒ†ãƒ 2ã¸ã®åˆ‡ã‚Šæ›¿ãˆ |
| **ç›®çš„ã®å•ã„ã‹ã‘** | ã€Œæœ¬å½“ã«å¿…è¦ï¼Ÿã€ã¨è³ªå• | ãƒ¡ã‚¿èªçŸ¥ã‚’æ´»æ€§åŒ– |
| **çµ±è¨ˆã®å¯è¦–åŒ–** | é˜»æ­¢ã—ãŸå›æ•°ã€ç¯€ç´„æ™‚é–“ã‚’è¡¨ç¤º | è‡ªå·±åŠ¹åŠ›æ„Ÿã®å‘ä¸Š |

#### one secã®æ”¹å–„ã®ä½™åœ°ã¨StopShortsã®å¯¾ç­–

| èª²é¡Œ | StopShortsã®å¯¾ç­– |
|------|-----------------|
| **æ…£ã‚Œã®å•é¡Œ** | è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ç­‰ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã§å¯¾å¿œ |
| **å—å‹•çš„** | ã‚¢ãƒ—ãƒªå†…è¨“ç·´ãƒ¢ãƒ¼ãƒ‰ã§èƒ½å‹•çš„ãªç·´ç¿’ã‚’æä¾› |
| **å˜ä¸€ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ** | If-Thenãƒ—ãƒ©ãƒ³ + è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã‚’çµ±åˆ |

---

## å¿ƒç†å­¦çš„åŸºç›¤

### ä¾å­˜ã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 

ã‚·ãƒ§ãƒ¼ãƒˆå‹•ç”»ä¾å­˜ã¯ä»¥ä¸‹ã®è¦å› ã§å½¢æˆã•ã‚Œã‚‹ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ãƒ‰ãƒ¼ãƒ‘ãƒŸãƒ³ãƒ»ãƒ«ãƒ¼ãƒ—                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚   [é€€å±ˆãƒ»ä¸å®‰ãƒ»ã‚¹ãƒˆãƒ¬ã‚¹]  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [ã‚¢ãƒ—ãƒªã‚’é–‹ãè¡å‹•]                             â”‚          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [ç„¡æ„è­˜ã«ã‚¢ãƒ—ãƒªã‚’é–‹ã]                         â”‚          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [å³åº§ã®å ±é…¬ï¼ˆæ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼‰]                â”‚          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [ãƒ‰ãƒ¼ãƒ‘ãƒŸãƒ³æ”¾å‡º]                               â”‚          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [ä¸€æ™‚çš„ãªæº€è¶³]                                 â”‚          â”‚
â”‚           â†“                                      â”‚          â”‚
â”‚   [ãƒ‰ãƒ¼ãƒ‘ãƒŸãƒ³ä½ä¸‹ â†’ é€€å±ˆãƒ»ä¸å®‰ã®å¢—å¤§] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### äºŒé‡éç¨‹ç†è«–ï¼ˆDual Process Theoryï¼‰

| ã‚·ã‚¹ãƒ†ãƒ  | ç‰¹å¾´ | ä¾‹ |
|----------|------|-----|
| **ã‚·ã‚¹ãƒ†ãƒ 1** | è‡ªå‹•çš„ã€é«˜é€Ÿã€ç„¡æ„è­˜ã€è¡å‹•çš„ | ç„¡æ„è­˜ã«ã‚¢ãƒ—ãƒªã‚’é–‹ã |
| **ã‚·ã‚¹ãƒ†ãƒ 2** | æ„è­˜çš„ã€ä½é€Ÿã€è«–ç†çš„ã€åˆ¶å¾¡çš„ | ã€Œæœ¬å½“ã«å¿…è¦ã‹ï¼Ÿã€ã¨è€ƒãˆã‚‹ |

**StopShortsã®æˆ¦ç•¥**: ã‚·ã‚¹ãƒ†ãƒ 1ã®è‡ªå‹•è¡Œå‹•ã‚’ä¸­æ–­ã—ã€ã‚·ã‚¹ãƒ†ãƒ 2ã‚’æ´»æ€§åŒ–ã•ã›ã‚‹

---

## ç¿’æ…£å½¢æˆã®æ ¸å¿ƒæ‰‹æ³•

StopShortsã¯2ã¤ã®ç§‘å­¦çš„ã«å®Ÿè¨¼ã•ã‚ŒãŸæ‰‹æ³•ã‚’æ ¸å¿ƒã¨ã—ã¦æ¡ç”¨ï¼š

### 1. Implementation Intentionsï¼ˆå®Ÿè¡Œæ„å›³ï¼‰- ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è¨­å®šæ¸ˆã¿

**æå”±è€…**: Peter Gollwitzerï¼ˆ1999ï¼‰

**æ¦‚è¦**: ã€ŒXãŒèµ·ããŸã‚‰ã€Yã‚’ã™ã‚‹ã€ã¨ã„ã†å½¢å¼ã§äº‹å‰ã«è¨ˆç”»ã‚’ç«‹ã¦ã‚‹

**ç ”ç©¶åŠ¹æœ**: ç›®æ¨™é”æˆç‡ãŒ2-3å€ã«å‘ä¸Š

**StopShortsã§ã®å®Ÿè£…**:
- ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ If-Then ãƒ—ãƒ©ãƒ³ã‚’è¨­å®šï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
- ä»‹å…¥æ™‚ã«è¨­å®šã—ãŸãƒ—ãƒ©ãƒ³ã‚’è¡¨ç¤º
- æ¯æ—¥ã®ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼ã§å¾©ç¿’

---

### 2. Urge Surfingï¼ˆè¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ï¼‰- æ ¸å¿ƒæ‰‹æ³•

**æå”±è€…**: Alan Marlattï¼ˆä¾å­˜ç—‡æ²»ç™‚ãƒ»å†ç™ºé˜²æ­¢ç ”ç©¶ï¼‰

**æ¦‚è¦**: è¡å‹•ã‚’ã€Œæ³¢ã€ã¨ã—ã¦è¦³å¯Ÿã—ã€åˆ¤æ–­ã›ãšã«ã‚„ã‚Šéã”ã™

**ãªãœåŠ¹æœçš„ã‹**:
- è¡å‹•ã¯æ°¸ç¶šã—ãªã„ï¼ˆé€šå¸¸15-30åˆ†ã§ãƒ”ãƒ¼ã‚¯ã‚’éãã‚‹ï¼‰
- è¡å‹•ã¨ã€Œæˆ¦ã†ã€ã®ã§ã¯ãªãã€Œè¦³å¯Ÿã™ã‚‹ã€ã“ã¨ã§ã€è¡å‹•ã«æ”¯é…ã•ã‚Œãªããªã‚‹
- ãƒã‚¤ãƒ³ãƒ‰ãƒ•ãƒ«ãƒã‚¹ã®åŸç†ã‚’å¿œç”¨ã—ã€è‡ªå‹•çš„ãªåå¿œãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¸­æ–­

**ç ”ç©¶åŠ¹æœ**: ä¾å­˜è¡Œå‹•ã®å†ç™ºé˜²æ­¢ã«åŠ¹æœçš„ï¼ˆè–¬ç‰©ã€ã‚¢ãƒ«ã‚³ãƒ¼ãƒ«ã€ã‚®ãƒ£ãƒ³ãƒ–ãƒ«ç­‰ã§å®Ÿè¨¼ï¼‰

#### è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **èªè­˜ã™ã‚‹ï¼ˆNoticeï¼‰** - ã€Œä»Šã€ã‚¢ãƒ—ãƒªã‚’é–‹ããŸã„ã¨ã„ã†è¡å‹•ãŒã‚ã‚‹ã€ã¨æ°—ã¥ã
2. **å—ã‘å…¥ã‚Œã‚‹ï¼ˆAcceptï¼‰** - è¡å‹•ã‚’å¦å®šã›ãšã€ã€Œã‚ã‚‹ãŒã¾ã¾ã€ã«èªã‚ã‚‹
3. **è¦³å¯Ÿã™ã‚‹ï¼ˆObserveï¼‰** - è¡å‹•ã‚’ç¬¬ä¸‰è€…è¦–ç‚¹ã§è¦³å¯Ÿã™ã‚‹
4. **å¾…ã¤ï¼ˆWaitï¼‰** - è¡å‹•ã¯æ³¢ã®ã‚ˆã†ã«å¿…ãšéãå»ã‚‹ã“ã¨ã‚’ä¿¡ã˜ã‚‹

---

## ã‚³ã‚¢æ©Ÿèƒ½è¨­è¨ˆ

### æ©Ÿèƒ½1: èµ·å‹•æ™‚ä»‹å…¥ï¼ˆShieldï¼‰

#### ãƒ•ãƒ­ãƒ¼

```
[ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒTikTokã‚’ã‚¿ãƒƒãƒ—]
        â†“
[DeviceActivityæ¤œçŸ¥]
        â†“
[ManagedSettingsã§ãƒ–ãƒ­ãƒƒã‚¯]
        â†“
[StopShortsã‚’ãƒ•ã‚©ã‚¢ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«èµ·å‹•]
        â†“
[è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚° or If-Thenç¢ºèª]
        â†“
[ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é¸æŠ: æ³¢ã«ä¹—ã‚‹ / é–‹ã]
```

#### ä»‹å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | èª¬æ˜ | é »åº¦ |
|----------|------|------|
| **è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°** | æ³¢ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ + æ·±å‘¼å¸ | 70% |
| **If-Thenç¢ºèª** | è¨­å®šã—ãŸãƒ—ãƒ©ãƒ³ã‚’è¡¨ç¤º + å®Ÿè¡Œ | 30% |

---

### æ©Ÿèƒ½2: ã‚¢ãƒ—ãƒªå†…è¨“ç·´ãƒ¢ãƒ¼ãƒ‰

#### ã‚³ãƒ³ã‚»ãƒ—ãƒˆ

StopShortså†…ã§TikToké¢¨ã®UIã‚’å†ç¾ã—ã€ã€Œã‚¹ãƒ¯ã‚¤ãƒ—â†’æ­¢ã¾ã‚‹â†’è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã€ã‚’ç·´ç¿’ã•ã›ã‚‹ã€‚

#### è¨“ç·´ãƒ¢ãƒ¼ãƒ‰ã®ç¨®é¡

| ãƒ¢ãƒ¼ãƒ‰ | èª¬æ˜ | é›£æ˜“åº¦ |
|--------|------|--------|
| **åŸºæœ¬è¨“ç·´** | 5å›ã‚¹ãƒ¯ã‚¤ãƒ—å¾Œã«è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚° | â˜…â˜†â˜† |
| **ãƒ©ãƒ³ãƒ€ãƒ è¨“ç·´** | ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ä»‹å…¥ | â˜…â˜…â˜† |
| **è¡å‹•èªè­˜è¨“ç·´** | è¡å‹•ã‚’æ„Ÿã˜ãŸã‚‰è‡ªåˆ†ã§æ­¢ã‚ã‚‹ | â˜…â˜…â˜… |

---

### æ©Ÿèƒ½3: 5åˆ†ã‚·ãƒ¼ãƒ«ãƒ‰

#### æ¦‚è¦
ã‚·ãƒ§ãƒ¼ãƒˆå‹•ç”»ã‚¢ãƒ—ãƒªã‚’ä¸€å®šæ™‚é–“ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚·ãƒ¼ãƒ«ãƒ‰ç”»é¢ã‚’è¡¨ç¤ºã€‚

#### ä»‹å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³

| ãƒ‘ã‚¿ãƒ¼ãƒ³ | 1å›ç›® | 2å›ç›® | 3å›ç›®ä»¥é™ |
|----------|-------|-------|----------|
| **ã‚„ã•ã—ã‚** | é–‰ã˜ã‚‹ã®ã¿ | é–‰ã˜ã‚‹ + StopShorts | StopShortsã®ã¿ |
| **æ¨™æº–** | é–‰ã˜ã‚‹ + StopShorts | StopShortsã®ã¿ | StopShortsã®ã¿ |
| **å³æ ¼** | StopShortsã®ã¿ | StopShortsã®ã¿ | StopShortsã®ã¿ |

---

## çµ±è¨ˆãƒ»åˆ†ææ©Ÿèƒ½

### ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```typescript
// src/types/statistics.ts

interface DailyStatistics {
  date: string;                           // ISO date (YYYY-MM-DD)
  totalUsageMinutes: number;              // ç·ä½¿ç”¨æ™‚é–“ï¼ˆåˆ†ï¼‰
  appBreakdown: {
    tiktok: number;
    youtubeShorts: number;
    instagramReels: number;
  };
  urgeSurfing: {
    completed: number;                    // æ³¢ã«ä¹—ã£ãŸå›æ•°
    skipped: number;                      // ã‚¹ã‚­ãƒƒãƒ—ã—ãŸå›æ•°
    totalDurationSeconds: number;         // åˆè¨ˆã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ™‚é–“
    averageIntensityBefore: number;       // å¹³å‡é–‹å§‹æ™‚è¡å‹•å¼·åº¦ (1-10)
    averageIntensityAfter: number;        // å¹³å‡çµ‚äº†æ™‚è¡å‹•å¼·åº¦ (1-10)
  };
  interventions: {
    triggered: number;                    // ä»‹å…¥å›æ•°
    dismissed: number;                    // ã‚„ã‚ãŸå›æ•°
    proceeded: number;                    // é–‹ã„ãŸå›æ•°
  };
  training: {
    sessionsCompleted: number;
    totalMinutes: number;
  };
  timeOfDayBreakdown: {
    morning: number;      // 6-9
    daytime: number;      // 9-17
    evening: number;      // 17-21
    night: number;        // 21-6
  };
}

interface WeeklyStatistics {
  weekStart: string;                      // ISO date
  weekEnd: string;
  dailyStats: DailyStatistics[];
  averageDailyUsage: number;
  totalUrgeSurfing: number;
  successRate: number;                    // completed / (completed + skipped)
  savedMinutes: number;                   // æ¨å®šç¯€ç´„æ™‚é–“
  comparedToPreviousWeek: {
    usageChange: number;                  // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆå¤‰åŒ–
    successRateChange: number;
  };
}

interface LifetimeStatistics {
  startDate: string;
  totalSavedHours: number;
  totalUrgeSurfingCompleted: number;
  totalInterventions: number;
  currentStreak: number;
  longestStreak: number;
  badges: Badge[];
}

interface Badge {
  id: string;
  name: string;
  description: string;
  icon: string;
  earnedAt: string | null;
  condition: BadgeCondition;
}

type BadgeCondition =
  | { type: 'first_surf' }
  | { type: 'streak'; days: number }
  | { type: 'total_surfs'; count: number }
  | { type: 'saved_hours'; hours: number };
```

---

## ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

### ã‚¹ãƒˆãƒªãƒ¼ã‚¯é”æˆæ¡ä»¶
- 1æ—¥ã®ä½¿ç”¨æ™‚é–“ãŒç›®æ¨™ä»¥å†…
- ã¾ãŸã¯ã€è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã‚’1å›ä»¥ä¸Šå®Œäº†

### ãƒãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ 

| ID | ãƒãƒƒã‚¸ | æ¡ä»¶ | èª¬æ˜ |
|----|--------|------|------|
| `first_wave` | ğŸŒŠ åˆã‚ã¦ã®æ³¢ | åˆã‚ã¦è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°å®Œäº† | ç¬¬ä¸€æ­©ã‚’è¸ã¿å‡ºã—ã¾ã—ãŸ |
| `streak_3` | ğŸ”¥ 3æ—¥é€£ç¶š | 3æ—¥é€£ç¶šé”æˆ | ç¿’æ…£ã®èŠ½ãŒå‡ºã¦ãã¾ã—ãŸ |
| `streak_7` | ğŸ’ª 1é€±é–“ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼ | 7æ—¥é€£ç¶šé”æˆ | æ³¢ä¹—ã‚ŠãŒä¸Šæ‰‹ã«ãªã£ã¦ãã¾ã—ãŸ |
| `streak_14` | â­ 2é€±é–“ãƒã‚¹ã‚¿ãƒ¼ | 14æ—¥é€£ç¶šé”æˆ | è¡å‹•ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã¦ã„ã¾ã™ |
| `streak_21` | ğŸ† 21æ—¥ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³ | 21æ—¥é€£ç¶šé”æˆ | æ–°ã—ã„ç¿’æ…£ãŒå½¢æˆã•ã‚Œã¾ã—ãŸï¼ |
| `streak_66` | ğŸ‘‘ 66æ—¥ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ | 66æ—¥é€£ç¶šé”æˆ | ç§‘å­¦çš„ã«ç¿’æ…£ãŒå®šç€ |
| `surfs_100` | ğŸ„ 100å›ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼ | 100å›è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°å®Œäº† | æ³¢ä¹—ã‚Šã®é”äºº |
| `saved_10h` | â° 10æ™‚é–“æ•‘æ¸ˆè€… | ç´¯è¨ˆ10æ™‚é–“ç¯€ç´„ | è²´é‡ãªæ™‚é–“ã‚’å–ã‚Šæˆ»ã—ã¾ã—ãŸ |

---

## æŠ€è¡“çš„å®Ÿè£…è¦ä»¶

### Screen Time API

| ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ | ç”¨é€” |
|---------------|------|
| `FamilyControls` | æ¨©é™å–å¾—ã€å¯¾è±¡ã‚¢ãƒ—ãƒªé¸æŠ |
| `DeviceActivity` | ã‚¢ãƒ—ãƒªèµ·å‹•ãƒ»ä½¿ç”¨æ™‚é–“ã®æ¤œçŸ¥ |
| `ManagedSettings` | ã‚¢ãƒ—ãƒªã®ãƒ–ãƒ­ãƒƒã‚¯ãƒ»è§£é™¤ |

### å¿…è¦ãªã‚¨ãƒ³ã‚¿ã‚¤ãƒˆãƒ«ãƒ¡ãƒ³ãƒˆ

```
com.apple.developer.family-controls
```

> âš ï¸ **æ³¨æ„**: Family Controls entitlementã¯Appleã¸ã®ç”³è«‹ãƒ»æ‰¿èªãŒå¿…è¦

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    StopShorts App                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚   React Native  â”‚  â”‚  Native Modules â”‚                  â”‚
â”‚  â”‚   (UI Layer)    â”‚â—„â”€â”‚  (Bridge)       â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚           â”‚                    â”‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚           Zustand Store              â”‚                  â”‚
â”‚  â”‚  (State Management + Persistence)    â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                   â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚         Statistics Service           â”‚                  â”‚
â”‚  â”‚  (Data Processing + Analytics)       â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    App Extensions                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ DeviceActivity  â”‚  â”‚ ShieldConfig    â”‚                  â”‚
â”‚  â”‚ Monitor         â”‚  â”‚ Extension       â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ ShieldAction    â”‚  â”‚ Activity        â”‚                  â”‚
â”‚  â”‚ Extension       â”‚  â”‚ Report          â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## è©³ç´°å®Ÿè£…è¨ˆç”»

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                          # æ—¢å­˜UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ urge-surfing/                # è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°é–¢é€£
â”‚   â”‚   â”œâ”€â”€ UrgeSurfingScreen.tsx    # ãƒ¡ã‚¤ãƒ³ç”»é¢
â”‚   â”‚   â”œâ”€â”€ WaveAnimation.tsx        # æ³¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
â”‚   â”‚   â”œâ”€â”€ IntensitySlider.tsx      # è¡å‹•å¼·åº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
â”‚   â”‚   â”œâ”€â”€ BreathingGuide.tsx       # æ·±å‘¼å¸ã‚¬ã‚¤ãƒ‰
â”‚   â”‚   â”œâ”€â”€ SurfingTimer.tsx         # ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
â”‚   â”‚   â””â”€â”€ CompletionScreen.tsx     # å®Œäº†ç”»é¢
â”‚   â”œâ”€â”€ training/                    # è¨“ç·´ãƒ¢ãƒ¼ãƒ‰é–¢é€£
â”‚   â”‚   â”œâ”€â”€ TrainingScreen.tsx       # ãƒ¡ã‚¤ãƒ³è¨“ç·´ç”»é¢
â”‚   â”‚   â”œâ”€â”€ MockVideoFeed.tsx        # TikToké¢¨ãƒ¢ãƒƒã‚¯ãƒ•ã‚£ãƒ¼ãƒ‰
â”‚   â”‚   â”œâ”€â”€ MockVideoCard.tsx        # å€‹åˆ¥å‹•ç”»ã‚«ãƒ¼ãƒ‰
â”‚   â”‚   â”œâ”€â”€ TrainingIntervention.tsx # è¨“ç·´ä¸­ã®ä»‹å…¥ç”»é¢
â”‚   â”‚   â””â”€â”€ TrainingComplete.tsx     # è¨“ç·´å®Œäº†ç”»é¢
â”‚   â””â”€â”€ statistics/                  # çµ±è¨ˆé–¢é€£
â”‚       â”œâ”€â”€ DashboardScreen.tsx      # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
â”‚       â”œâ”€â”€ DetailedStatsScreen.tsx  # è©³ç´°çµ±è¨ˆ
â”‚       â”œâ”€â”€ WeeklyChart.tsx          # é€±é–“ã‚°ãƒ©ãƒ•
â”‚       â”œâ”€â”€ StreakDisplay.tsx        # ã‚¹ãƒˆãƒªãƒ¼ã‚¯è¡¨ç¤º
â”‚       â””â”€â”€ BadgeGrid.tsx            # ãƒãƒƒã‚¸ä¸€è¦§
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ statistics.ts                # çµ±è¨ˆè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”œâ”€â”€ badges.ts                    # ãƒãƒƒã‚¸åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
â”‚   â””â”€â”€ notifications.ts             # é€šçŸ¥ç®¡ç†
â”‚
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ useAppStore.ts               # æ—¢å­˜ã‚¹ãƒˆã‚¢ï¼ˆæ‹¡å¼µï¼‰
â”‚   â””â”€â”€ useStatisticsStore.ts        # çµ±è¨ˆå°‚ç”¨ã‚¹ãƒˆã‚¢
â”‚
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ index.ts                     # æ—¢å­˜å‹å®šç¾©
â”‚   â””â”€â”€ statistics.ts                # çµ±è¨ˆé–¢é€£å‹å®šç¾©
â”‚
â””â”€â”€ native/                          # ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    â””â”€â”€ ScreenTimeModule.ts          # Screen Time API ãƒ–ãƒªãƒƒã‚¸

app/
â”œâ”€â”€ (main)/
â”‚   â”œâ”€â”€ index.tsx                    # ãƒ›ãƒ¼ãƒ ç”»é¢ï¼ˆæ‹¡å¼µï¼‰
â”‚   â”œâ”€â”€ training.tsx                 # è¨“ç·´ãƒ¢ãƒ¼ãƒ‰
â”‚   â”œâ”€â”€ statistics.tsx               # çµ±è¨ˆç”»é¢ï¼ˆæ‹¡å¼µï¼‰
â”‚   â””â”€â”€ urge-surfing.tsx             # è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ç”»é¢
â”‚
ios/
â”œâ”€â”€ StopShorts/
â”‚   â””â”€â”€ ScreenTimeModule.swift       # Screen Time ãƒã‚¤ãƒ†ã‚£ãƒ–å®Ÿè£…
â”œâ”€â”€ DeviceActivityMonitor/           # App Extension
â”‚   â””â”€â”€ DeviceActivityMonitorExtension.swift
â”œâ”€â”€ ShieldConfiguration/             # App Extension
â”‚   â””â”€â”€ ShieldConfigurationExtension.swift
â””â”€â”€ ShieldAction/                    # App Extension
    â””â”€â”€ ShieldActionExtension.swift
```

---

### Phase 1: è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°UIï¼ˆReact Nativeï¼‰

#### 1.1 WaveAnimation ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// src/components/urge-surfing/WaveAnimation.tsx

import React from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
  interpolate,
} from 'react-native-reanimated';
import Svg, { Path } from 'react-native-svg';

interface WaveAnimationProps {
  /** ç¾åœ¨ã®é€²è¡Œåº¦ (0-1) */
  progress: number;
  /** ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹ã‹ */
  showSurfer?: boolean;
  /** æ³¢ã®è‰² */
  waveColor?: string;
}

export function WaveAnimation({
  progress,
  showSurfer = true,
  waveColor = '#4A90D9',
}: WaveAnimationProps) {
  const { width } = Dimensions.get('window');
  const waveOffset = useSharedValue(0);

  React.useEffect(() => {
    waveOffset.value = withRepeat(
      withTiming(1, { duration: 2000, easing: Easing.linear }),
      -1,
      false
    );
  }, []);

  // æ³¢ã®ä½ç½®ï¼ˆé€²è¡Œåº¦ã«å¿œã˜ã¦ä¸‹ãŒã‚‹ï¼‰
  const wavePosition = interpolate(progress, [0, 1], [0.3, 0.7]);

  // ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼ã®ä½ç½®ï¼ˆæ³¢ã®ä¸Šã‚’ç§»å‹•ï¼‰
  const surferY = interpolate(progress, [0, 0.5, 1], [0.3, 0.15, 0.7]);

  const animatedWaveStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: waveOffset.value * -width }],
  }));

  return (
    <View style={styles.container}>
      {/* æ³¢ã®SVGã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */}
      <Animated.View style={[styles.waveContainer, animatedWaveStyle]}>
        <Svg width={width * 2} height={200} viewBox={`0 0 ${width * 2} 200`}>
          <Path
            d={generateWavePath(width * 2, 200, wavePosition)}
            fill={waveColor}
            opacity={0.6}
          />
        </Svg>
      </Animated.View>

      {/* ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ */}
      {showSurfer && (
        <View style={[styles.surfer, { top: `${surferY * 100}%` }]}>
          <Text style={styles.surferEmoji}>ğŸ„</Text>
        </View>
      )}
    </View>
  );
}

function generateWavePath(width: number, height: number, yPosition: number): string {
  const y = height * yPosition;
  const amplitude = 20;
  let path = `M 0 ${y}`;

  for (let x = 0; x <= width; x += 10) {
    const waveY = y + Math.sin(x * 0.02) * amplitude;
    path += ` L ${x} ${waveY}`;
  }

  path += ` L ${width} ${height} L 0 ${height} Z`;
  return path;
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    overflow: 'hidden',
  },
  waveContainer: {
    position: 'absolute',
    bottom: 0,
  },
  surfer: {
    position: 'absolute',
    left: '50%',
    marginLeft: -20,
  },
  surferEmoji: {
    fontSize: 40,
  },
});
```

#### 1.2 IntensitySlider ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// src/components/urge-surfing/IntensitySlider.tsx

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  runOnJS,
} from 'react-native-reanimated';
import { useTheme } from '../../contexts/ThemeContext';

interface IntensitySliderProps {
  value: number;              // 1-10
  onChange: (value: number) => void;
  disabled?: boolean;
}

export function IntensitySlider({
  value,
  onChange,
  disabled = false,
}: IntensitySliderProps) {
  const { colors, spacing } = useTheme();
  const sliderWidth = useSharedValue(0);
  const translateX = useSharedValue((value - 1) / 9);

  const panGesture = Gesture.Pan()
    .enabled(!disabled)
    .onUpdate((event) => {
      const newValue = Math.max(0, Math.min(1, event.x / sliderWidth.value));
      translateX.value = newValue;
      const intensity = Math.round(newValue * 9) + 1;
      runOnJS(onChange)(intensity);
    });

  const thumbStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: translateX.value * sliderWidth.value - 15 }],
  }));

  const getIntensityLabel = (val: number): string => {
    if (val <= 3) return 'å¼±ã„';
    if (val <= 6) return 'ä¸­ãã‚‰ã„';
    return 'å¼·ã„';
  };

  const getIntensityColor = (val: number): string => {
    if (val <= 3) return colors.success;
    if (val <= 6) return colors.warning;
    return colors.error;
  };

  return (
    <View style={styles.container}>
      <View style={styles.labels}>
        <Text style={[styles.label, { color: colors.textMuted }]}>å¼±ã„</Text>
        <Text style={[styles.label, { color: colors.textMuted }]}>å¼·ã„</Text>
      </View>

      <GestureDetector gesture={panGesture}>
        <View
          style={[styles.track, { backgroundColor: colors.backgroundCard }]}
          onLayout={(e) => {
            sliderWidth.value = e.nativeEvent.layout.width;
          }}
        >
          {/* é€²æ—ãƒãƒ¼ */}
          <Animated.View
            style={[
              styles.progress,
              {
                backgroundColor: getIntensityColor(value),
                width: `${((value - 1) / 9) * 100}%`,
              },
            ]}
          />

          {/* ã¤ã¾ã¿ */}
          <Animated.View
            style={[
              styles.thumb,
              thumbStyle,
              { backgroundColor: getIntensityColor(value) },
            ]}
          />
        </View>
      </GestureDetector>

      <Text
        style={[
          styles.currentValue,
          { color: getIntensityColor(value) },
        ]}
      >
        {value} - {getIntensityLabel(value)}
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    width: '100%',
    paddingVertical: 16,
  },
  labels: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  label: {
    fontSize: 12,
  },
  track: {
    height: 8,
    borderRadius: 4,
    overflow: 'hidden',
  },
  progress: {
    height: '100%',
    borderRadius: 4,
  },
  thumb: {
    position: 'absolute',
    width: 30,
    height: 30,
    borderRadius: 15,
    top: -11,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 4,
  },
  currentValue: {
    textAlign: 'center',
    marginTop: 16,
    fontSize: 16,
    fontWeight: '600',
  },
});
```

#### 1.3 BreathingGuide ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// src/components/urge-surfing/BreathingGuide.tsx

import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSequence,
  withTiming,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { useTheme } from '../../contexts/ThemeContext';

interface BreathingGuideProps {
  /** å‘¼å¸ã‚µã‚¤ã‚¯ãƒ«æ•° */
  cycles: number;
  /** å®Œäº†æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onComplete: () => void;
  /** å¸ã†æ™‚é–“ï¼ˆmsï¼‰ */
  inhaleMs?: number;
  /** æ­¢ã‚ã‚‹æ™‚é–“ï¼ˆmsï¼‰ */
  holdMs?: number;
  /** åãæ™‚é–“ï¼ˆmsï¼‰ */
  exhaleMs?: number;
}

type BreathPhase = 'inhale' | 'hold' | 'exhale' | 'rest';

export function BreathingGuide({
  cycles,
  onComplete,
  inhaleMs = 4000,
  holdMs = 2000,
  exhaleMs = 4000,
}: BreathingGuideProps) {
  const { colors, typography } = useTheme();
  const [currentCycle, setCurrentCycle] = useState(1);
  const [phase, setPhase] = useState<BreathPhase>('inhale');

  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  const cycleMs = inhaleMs + holdMs + exhaleMs + 500; // 500ms rest

  useEffect(() => {
    const runBreathCycle = () => {
      // å¸ã†
      setPhase('inhale');
      scale.value = withTiming(1.5, {
        duration: inhaleMs,
        easing: Easing.inOut(Easing.ease),
      });

      // æ­¢ã‚ã‚‹
      setTimeout(() => {
        setPhase('hold');
      }, inhaleMs);

      // åã
      setTimeout(() => {
        setPhase('exhale');
        scale.value = withTiming(1, {
          duration: exhaleMs,
          easing: Easing.inOut(Easing.ease),
        });
      }, inhaleMs + holdMs);

      // æ¬¡ã®ã‚µã‚¤ã‚¯ãƒ«ã¸
      setTimeout(() => {
        setPhase('rest');
        if (currentCycle < cycles) {
          setCurrentCycle((c) => c + 1);
        } else {
          onComplete();
        }
      }, cycleMs - 500);
    };

    runBreathCycle();
    const interval = setInterval(runBreathCycle, cycleMs);

    return () => clearInterval(interval);
  }, [currentCycle, cycles]);

  const animatedCircleStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const getPhaseText = (): string => {
    switch (phase) {
      case 'inhale':
        return 'å¸ã£ã¦...';
      case 'hold':
        return 'æ­¢ã‚ã¦...';
      case 'exhale':
        return 'åã„ã¦...';
      default:
        return '';
    }
  };

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.circle,
          animatedCircleStyle,
          { backgroundColor: colors.primary + '40' },
        ]}
      >
        <View
          style={[
            styles.innerCircle,
            { backgroundColor: colors.primary },
          ]}
        />
      </Animated.View>

      <Text style={[typography.h2, { color: colors.textPrimary, marginTop: 32 }]}>
        {getPhaseText()}
      </Text>

      <View style={styles.cycleIndicator}>
        {Array.from({ length: cycles }).map((_, i) => (
          <View
            key={i}
            style={[
              styles.cycleDot,
              {
                backgroundColor:
                  i < currentCycle ? colors.primary : colors.borderSubtle,
              },
            ]}
          />
        ))}
      </View>

      <Text style={[typography.caption, { color: colors.textMuted }]}>
        {currentCycle} / {cycles} å›ç›®
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  circle: {
    width: 120,
    height: 120,
    borderRadius: 60,
    alignItems: 'center',
    justifyContent: 'center',
  },
  innerCircle: {
    width: 60,
    height: 60,
    borderRadius: 30,
  },
  cycleIndicator: {
    flexDirection: 'row',
    marginTop: 24,
    gap: 8,
  },
  cycleDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
});
```

#### 1.4 UrgeSurfingScreen ç”»é¢

```typescript
// src/components/urge-surfing/UrgeSurfingScreen.tsx

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import Animated, { FadeIn, FadeOut } from 'react-native-reanimated';
import { useTheme } from '../../contexts/ThemeContext';
import { useStatisticsStore } from '../../stores/useStatisticsStore';
import { Button } from '../ui';
import { WaveAnimation } from './WaveAnimation';
import { IntensitySlider } from './IntensitySlider';
import { BreathingGuide } from './BreathingGuide';

type SurfingPhase = 'initial' | 'surfing' | 'complete';

interface UrgeSurfingScreenProps {
  /** ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸã‚¢ãƒ—ãƒªå */
  blockedAppName?: string;
  /** é–‹ããƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ */
  onProceed: () => void;
  /** ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹æ™‚ */
  onDismiss: () => void;
}

export function UrgeSurfingScreen({
  blockedAppName = 'TikTok',
  onProceed,
  onDismiss,
}: UrgeSurfingScreenProps) {
  const { colors, typography, spacing } = useTheme();
  const [phase, setPhase] = useState<SurfingPhase>('initial');
  const [intensityBefore, setIntensityBefore] = useState(5);
  const [intensityAfter, setIntensityAfter] = useState(5);
  const [surfingProgress, setSurfingProgress] = useState(0);

  const { recordUrgeSurfing } = useStatisticsStore();

  const SURFING_DURATION_MS = 30000; // 30ç§’
  const BREATH_CYCLES = 3;

  const handleStartSurfing = useCallback(() => {
    setPhase('surfing');

    // é€²æ—ã‚’æ›´æ–°
    const startTime = Date.now();
    const interval = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / SURFING_DURATION_MS, 1);
      setSurfingProgress(progress);

      if (progress >= 1) {
        clearInterval(interval);
      }
    }, 100);
  }, []);

  const handleBreathingComplete = useCallback(() => {
    setPhase('complete');

    // çµ±è¨ˆã‚’è¨˜éŒ²
    recordUrgeSurfing({
      intensityBefore,
      intensityAfter,
      durationSeconds: SURFING_DURATION_MS / 1000,
      completed: true,
    });
  }, [intensityBefore, intensityAfter, recordUrgeSurfing]);

  const handleSkip = useCallback(() => {
    recordUrgeSurfing({
      intensityBefore,
      intensityAfter: intensityBefore,
      durationSeconds: 0,
      completed: false,
    });
    onProceed();
  }, [intensityBefore, recordUrgeSurfing, onProceed]);

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: colors.background }]}>
      {phase === 'initial' && (
        <Animated.View
          entering={FadeIn}
          exiting={FadeOut}
          style={styles.content}
        >
          <Text style={[typography.h2, { color: colors.textPrimary, textAlign: 'center' }]}>
            â¸ï¸ ã¡ã‚‡ã£ã¨å¾…ã£ã¦
          </Text>

          <Text style={[typography.body, { color: colors.textSecondary, textAlign: 'center', marginTop: 8 }]}>
            {blockedAppName}ã‚’é–‹ã“ã†ã¨ã—ã¦ã„ã¾ã™
          </Text>

          <View style={[styles.section, { marginTop: spacing.xl }]}>
            <Text style={[typography.bodyLarge, { color: colors.textPrimary }]}>
              ä»Šã®è¡å‹•ã‚’è¦³å¯Ÿã—ã¦ã¿ã¾ã—ã‚‡ã†
            </Text>
            <Text style={[typography.caption, { color: colors.textMuted, marginTop: 4 }]}>
              è¡å‹•ã®å¼·ã•ã¯ï¼Ÿ
            </Text>

            <IntensitySlider
              value={intensityBefore}
              onChange={setIntensityBefore}
            />
          </View>

          <View style={styles.buttonContainer}>
            <Button
              title="ğŸŒŠ æ³¢ã«ä¹—ã‚‹ï¼ˆ30ç§’ï¼‰"
              onPress={handleStartSurfing}
              size="lg"
            />

            <Button
              title="ä»Šã™ãé–‹ã"
              onPress={handleSkip}
              variant="outline"
              size="lg"
              style={{ marginTop: spacing.md }}
            />
          </View>
        </Animated.View>
      )}

      {phase === 'surfing' && (
        <Animated.View
          entering={FadeIn}
          exiting={FadeOut}
          style={styles.content}
        >
          <Text style={[typography.h2, { color: colors.textPrimary, textAlign: 'center' }]}>
            ğŸŒŠ è¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ä¸­
          </Text>

          <View style={styles.waveContainer}>
            <WaveAnimation
              progress={surfingProgress}
              showSurfer={true}
              waveColor={colors.primary}
            />
          </View>

          <BreathingGuide
            cycles={BREATH_CYCLES}
            onComplete={handleBreathingComplete}
          />

          <Text style={[typography.caption, { color: colors.textMuted, textAlign: 'center', marginTop: 16 }]}>
            ğŸ’­ ã€Œã“ã®è¡å‹•ã¯ä¸€æ™‚çš„ãªã‚‚ã®ã€‚æ³¢ã®ã‚ˆã†ã«ã€å¿…ãšéãã¦ã„ãã€
          </Text>
        </Animated.View>
      )}

      {phase === 'complete' && (
        <Animated.View
          entering={FadeIn}
          exiting={FadeOut}
          style={styles.content}
        >
          <Text style={[typography.h1, { color: colors.textPrimary, textAlign: 'center' }]}>
            âœ¨ ç´ æ™´ã‚‰ã—ã„ï¼
          </Text>

          <Text style={[typography.bodyLarge, { color: colors.textSecondary, textAlign: 'center', marginTop: 8 }]}>
            æ³¢ã‚’ä¹—ã‚Šè¶Šãˆã¾ã—ãŸ ğŸ„
          </Text>

          <View style={[styles.section, { marginTop: spacing.xl }]}>
            <Text style={[typography.body, { color: colors.textPrimary }]}>
              ä»Šã®è¡å‹•ã®å¼·ã•ã¯ï¼Ÿ
            </Text>

            <IntensitySlider
              value={intensityAfter}
              onChange={setIntensityAfter}
            />
          </View>

          <View style={[styles.comparisonCard, { backgroundColor: colors.backgroundCard }]}>
            <Text style={[typography.caption, { color: colors.textMuted }]}>
              è¡å‹•ã®å¼·ã•ã®å¤‰åŒ–
            </Text>
            <View style={styles.comparisonRow}>
              <Text style={[typography.body, { color: colors.textPrimary }]}>
                é–‹å§‹æ™‚: {intensityBefore}
              </Text>
              <Text style={[typography.body, { color: colors.textPrimary }]}>
                â†’
              </Text>
              <Text style={[typography.body, { color: colors.success }]}>
                ä»Š: {intensityAfter}
              </Text>
            </View>
          </View>

          <View style={styles.buttonContainer}>
            <Button
              title="ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹"
              onPress={onDismiss}
              size="lg"
            />

            <Button
              title="ã‚„ã£ã±ã‚Šé–‹ã"
              onPress={onProceed}
              variant="outline"
              size="lg"
              style={{ marginTop: spacing.md }}
            />
          </View>
        </Animated.View>
      )}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 24,
    justifyContent: 'center',
  },
  section: {
    width: '100%',
  },
  waveContainer: {
    height: 200,
    marginVertical: 24,
  },
  buttonContainer: {
    marginTop: 32,
  },
  comparisonCard: {
    padding: 16,
    borderRadius: 12,
    marginTop: 16,
  },
  comparisonRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    marginTop: 8,
  },
});
```

---

### Phase 2: çµ±è¨ˆã‚¹ãƒˆã‚¢

```typescript
// src/stores/useStatisticsStore.ts

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  DailyStatistics,
  WeeklyStatistics,
  LifetimeStatistics,
  Badge,
} from '../types/statistics';
import { checkBadges, BADGE_DEFINITIONS } from '../services/badges';

interface UrgeSurfingRecord {
  intensityBefore: number;
  intensityAfter: number;
  durationSeconds: number;
  completed: boolean;
}

interface StatisticsState {
  // ãƒ‡ãƒ¼ã‚¿
  dailyStats: Record<string, DailyStatistics>;  // key: YYYY-MM-DD
  lifetime: LifetimeStatistics;

  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  recordUrgeSurfing: (record: UrgeSurfingRecord) => void;
  recordIntervention: (proceeded: boolean) => void;
  recordUsageTime: (appId: string, minutes: number) => void;
  recordTrainingSession: (minutes: number) => void;

  // ã‚²ãƒƒã‚¿ãƒ¼
  getTodayStats: () => DailyStatistics;
  getWeeklyStats: () => WeeklyStatistics;
  getStreak: () => number;
  getNewBadges: () => Badge[];

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  resetDailyStats: () => void;
}

const getDateKey = (date: Date = new Date()): string => {
  return date.toISOString().split('T')[0];
};

const createEmptyDailyStats = (date: string): DailyStatistics => ({
  date,
  totalUsageMinutes: 0,
  appBreakdown: {
    tiktok: 0,
    youtubeShorts: 0,
    instagramReels: 0,
  },
  urgeSurfing: {
    completed: 0,
    skipped: 0,
    totalDurationSeconds: 0,
    averageIntensityBefore: 0,
    averageIntensityAfter: 0,
  },
  interventions: {
    triggered: 0,
    dismissed: 0,
    proceeded: 0,
  },
  training: {
    sessionsCompleted: 0,
    totalMinutes: 0,
  },
  timeOfDayBreakdown: {
    morning: 0,
    daytime: 0,
    evening: 0,
    night: 0,
  },
});

const createEmptyLifetime = (): LifetimeStatistics => ({
  startDate: new Date().toISOString(),
  totalSavedHours: 0,
  totalUrgeSurfingCompleted: 0,
  totalInterventions: 0,
  currentStreak: 0,
  longestStreak: 0,
  badges: BADGE_DEFINITIONS.map((def) => ({
    ...def,
    earnedAt: null,
  })),
});

export const useStatisticsStore = create<StatisticsState>()(
  persist(
    (set, get) => ({
      dailyStats: {},
      lifetime: createEmptyLifetime(),

      recordUrgeSurfing: (record) => {
        const dateKey = getDateKey();
        const state = get();
        const todayStats = state.dailyStats[dateKey] || createEmptyDailyStats(dateKey);

        const newUrgeSurfing = { ...todayStats.urgeSurfing };

        if (record.completed) {
          newUrgeSurfing.completed += 1;
          newUrgeSurfing.totalDurationSeconds += record.durationSeconds;

          // å¹³å‡å¼·åº¦ã‚’å†è¨ˆç®—
          const totalCompleted = newUrgeSurfing.completed;
          newUrgeSurfing.averageIntensityBefore =
            (newUrgeSurfing.averageIntensityBefore * (totalCompleted - 1) +
              record.intensityBefore) /
            totalCompleted;
          newUrgeSurfing.averageIntensityAfter =
            (newUrgeSurfing.averageIntensityAfter * (totalCompleted - 1) +
              record.intensityAfter) /
            totalCompleted;
        } else {
          newUrgeSurfing.skipped += 1;
        }

        const newLifetime = { ...state.lifetime };
        if (record.completed) {
          newLifetime.totalUrgeSurfingCompleted += 1;
        }

        // ãƒãƒƒã‚¸ãƒã‚§ãƒƒã‚¯
        const updatedBadges = checkBadges(newLifetime, {
          ...state.dailyStats,
          [dateKey]: { ...todayStats, urgeSurfing: newUrgeSurfing },
        });

        set({
          dailyStats: {
            ...state.dailyStats,
            [dateKey]: {
              ...todayStats,
              urgeSurfing: newUrgeSurfing,
            },
          },
          lifetime: {
            ...newLifetime,
            badges: updatedBadges,
          },
        });
      },

      recordIntervention: (proceeded) => {
        const dateKey = getDateKey();
        const state = get();
        const todayStats = state.dailyStats[dateKey] || createEmptyDailyStats(dateKey);

        const newInterventions = { ...todayStats.interventions };
        newInterventions.triggered += 1;

        if (proceeded) {
          newInterventions.proceeded += 1;
        } else {
          newInterventions.dismissed += 1;
        }

        set({
          dailyStats: {
            ...state.dailyStats,
            [dateKey]: {
              ...todayStats,
              interventions: newInterventions,
            },
          },
          lifetime: {
            ...state.lifetime,
            totalInterventions: state.lifetime.totalInterventions + 1,
          },
        });
      },

      recordUsageTime: (appId, minutes) => {
        const dateKey = getDateKey();
        const state = get();
        const todayStats = state.dailyStats[dateKey] || createEmptyDailyStats(dateKey);

        const newBreakdown = { ...todayStats.appBreakdown };
        const appKey = appId as keyof typeof newBreakdown;
        if (appKey in newBreakdown) {
          newBreakdown[appKey] += minutes;
        }

        // æ™‚é–“å¸¯ã‚’åˆ¤å®š
        const hour = new Date().getHours();
        const newTimeBreakdown = { ...todayStats.timeOfDayBreakdown };
        if (hour >= 6 && hour < 9) {
          newTimeBreakdown.morning += minutes;
        } else if (hour >= 9 && hour < 17) {
          newTimeBreakdown.daytime += minutes;
        } else if (hour >= 17 && hour < 21) {
          newTimeBreakdown.evening += minutes;
        } else {
          newTimeBreakdown.night += minutes;
        }

        set({
          dailyStats: {
            ...state.dailyStats,
            [dateKey]: {
              ...todayStats,
              totalUsageMinutes: todayStats.totalUsageMinutes + minutes,
              appBreakdown: newBreakdown,
              timeOfDayBreakdown: newTimeBreakdown,
            },
          },
        });
      },

      recordTrainingSession: (minutes) => {
        const dateKey = getDateKey();
        const state = get();
        const todayStats = state.dailyStats[dateKey] || createEmptyDailyStats(dateKey);

        set({
          dailyStats: {
            ...state.dailyStats,
            [dateKey]: {
              ...todayStats,
              training: {
                sessionsCompleted: todayStats.training.sessionsCompleted + 1,
                totalMinutes: todayStats.training.totalMinutes + minutes,
              },
            },
          },
        });
      },

      getTodayStats: () => {
        const dateKey = getDateKey();
        return get().dailyStats[dateKey] || createEmptyDailyStats(dateKey);
      },

      getWeeklyStats: () => {
        const state = get();
        const today = new Date();
        const weekStart = new Date(today);
        weekStart.setDate(today.getDate() - today.getDay());

        const dailyStatsArray: DailyStatistics[] = [];

        for (let i = 0; i < 7; i++) {
          const date = new Date(weekStart);
          date.setDate(weekStart.getDate() + i);
          const dateKey = getDateKey(date);
          dailyStatsArray.push(
            state.dailyStats[dateKey] || createEmptyDailyStats(dateKey)
          );
        }

        const totalUsage = dailyStatsArray.reduce(
          (sum, d) => sum + d.totalUsageMinutes,
          0
        );
        const totalSurfing = dailyStatsArray.reduce(
          (sum, d) => sum + d.urgeSurfing.completed,
          0
        );
        const totalSkipped = dailyStatsArray.reduce(
          (sum, d) => sum + d.urgeSurfing.skipped,
          0
        );

        return {
          weekStart: getDateKey(weekStart),
          weekEnd: getDateKey(today),
          dailyStats: dailyStatsArray,
          averageDailyUsage: totalUsage / 7,
          totalUrgeSurfing: totalSurfing,
          successRate:
            totalSurfing + totalSkipped > 0
              ? totalSurfing / (totalSurfing + totalSkipped)
              : 0,
          savedMinutes: totalSurfing * 5, // 1å›ã®ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã§æ¨å®š5åˆ†ç¯€ç´„
          comparedToPreviousWeek: {
            usageChange: 0, // TODO: å‰é€±ã¨ã®æ¯”è¼ƒ
            successRateChange: 0,
          },
        };
      },

      getStreak: () => {
        return get().lifetime.currentStreak;
      },

      getNewBadges: () => {
        const badges = get().lifetime.badges;
        // ç›´è¿‘24æ™‚é–“ä»¥å†…ã«ç²å¾—ã—ãŸãƒãƒƒã‚¸
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
        return badges.filter(
          (b) => b.earnedAt && b.earnedAt > oneDayAgo
        );
      },

      resetDailyStats: () => {
        set({ dailyStats: {} });
      },
    }),
    {
      name: 'statistics-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);
```

---

### Phase 3: ãƒãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ 

```typescript
// src/services/badges.ts

import { Badge, BadgeCondition, LifetimeStatistics, DailyStatistics } from '../types/statistics';

export const BADGE_DEFINITIONS: Omit<Badge, 'earnedAt'>[] = [
  {
    id: 'first_wave',
    name: 'åˆã‚ã¦ã®æ³¢',
    description: 'ç¬¬ä¸€æ­©ã‚’è¸ã¿å‡ºã—ã¾ã—ãŸ',
    icon: 'ğŸŒŠ',
    condition: { type: 'first_surf' },
  },
  {
    id: 'streak_3',
    name: '3æ—¥é€£ç¶š',
    description: 'ç¿’æ…£ã®èŠ½ãŒå‡ºã¦ãã¾ã—ãŸ',
    icon: 'ğŸ”¥',
    condition: { type: 'streak', days: 3 },
  },
  {
    id: 'streak_7',
    name: '1é€±é–“ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼',
    description: 'æ³¢ä¹—ã‚ŠãŒä¸Šæ‰‹ã«ãªã£ã¦ãã¾ã—ãŸ',
    icon: 'ğŸ’ª',
    condition: { type: 'streak', days: 7 },
  },
  {
    id: 'streak_14',
    name: '2é€±é–“ãƒã‚¹ã‚¿ãƒ¼',
    description: 'è¡å‹•ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã¦ã„ã¾ã™',
    icon: 'â­',
    condition: { type: 'streak', days: 14 },
  },
  {
    id: 'streak_21',
    name: '21æ—¥ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³',
    description: 'æ–°ã—ã„ç¿’æ…£ãŒå½¢æˆã•ã‚Œã¾ã—ãŸï¼',
    icon: 'ğŸ†',
    condition: { type: 'streak', days: 21 },
  },
  {
    id: 'streak_66',
    name: '66æ—¥ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰',
    description: 'ç§‘å­¦çš„ã«ç¿’æ…£ãŒå®šç€',
    icon: 'ğŸ‘‘',
    condition: { type: 'streak', days: 66 },
  },
  {
    id: 'surfs_100',
    name: '100å›ã‚µãƒ¼ãƒ•ã‚¡ãƒ¼',
    description: 'æ³¢ä¹—ã‚Šã®é”äºº',
    icon: 'ğŸ„',
    condition: { type: 'total_surfs', count: 100 },
  },
  {
    id: 'saved_10h',
    name: '10æ™‚é–“æ•‘æ¸ˆè€…',
    description: 'è²´é‡ãªæ™‚é–“ã‚’å–ã‚Šæˆ»ã—ã¾ã—ãŸ',
    icon: 'â°',
    condition: { type: 'saved_hours', hours: 10 },
  },
];

export function checkBadges(
  lifetime: LifetimeStatistics,
  dailyStats: Record<string, DailyStatistics>
): Badge[] {
  const now = new Date().toISOString();

  return lifetime.badges.map((badge) => {
    // æ—¢ã«ç²å¾—æ¸ˆã¿
    if (badge.earnedAt) {
      return badge;
    }

    const earned = checkCondition(badge.condition, lifetime, dailyStats);

    if (earned) {
      return { ...badge, earnedAt: now };
    }

    return badge;
  });
}

function checkCondition(
  condition: BadgeCondition,
  lifetime: LifetimeStatistics,
  dailyStats: Record<string, DailyStatistics>
): boolean {
  switch (condition.type) {
    case 'first_surf':
      return lifetime.totalUrgeSurfingCompleted >= 1;

    case 'streak':
      return lifetime.currentStreak >= condition.days;

    case 'total_surfs':
      return lifetime.totalUrgeSurfingCompleted >= condition.count;

    case 'saved_hours':
      return lifetime.totalSavedHours >= condition.hours;

    default:
      return false;
  }
}

export function calculateStreak(dailyStats: Record<string, DailyStatistics>): number {
  const today = new Date();
  let streak = 0;
  let currentDate = new Date(today);

  while (true) {
    const dateKey = currentDate.toISOString().split('T')[0];
    const stats = dailyStats[dateKey];

    // ãã®æ—¥ã«ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã‚’å®Œäº†ã—ãŸã‹ã€ä½¿ç”¨æ™‚é–“ãŒç›®æ¨™ä»¥å†…ã‹
    const achieved =
      stats &&
      (stats.urgeSurfing.completed > 0 || stats.totalUsageMinutes <= 30);

    if (achieved) {
      streak++;
      currentDate.setDate(currentDate.getDate() - 1);
    } else {
      break;
    }
  }

  return streak;
}
```

---

### Phase 4: Screen Time ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

```swift
// ios/StopShorts/ScreenTimeModule.swift

import Foundation
import FamilyControls
import DeviceActivity
import ManagedSettings

@objc(ScreenTimeModule)
class ScreenTimeModule: NSObject {

  private let center = AuthorizationCenter.shared
  private let store = ManagedSettingsStore()

  @objc
  func requestAuthorization(_ resolve: @escaping RCTPromiseResolveBlock,
                            rejecter reject: @escaping RCTPromiseRejectBlock) {
    Task {
      do {
        try await center.requestAuthorization(for: .individual)
        resolve(true)
      } catch {
        reject("AUTH_ERROR", error.localizedDescription, error)
      }
    }
  }

  @objc
  func getAuthorizationStatus(_ resolve: @escaping RCTPromiseResolveBlock,
                              rejecter reject: @escaping RCTPromiseRejectBlock) {
    switch center.authorizationStatus {
    case .notDetermined:
      resolve("notDetermined")
    case .denied:
      resolve("denied")
    case .approved:
      resolve("approved")
    @unknown default:
      resolve("unknown")
    }
  }

  @objc
  func setShieldedApps(_ bundleIds: [String],
                       resolve: @escaping RCTPromiseResolveBlock,
                       rejecter reject: @escaping RCTPromiseRejectBlock) {
    // Family Controls APIã§ã‚¢ãƒ—ãƒªã‚’ã‚·ãƒ¼ãƒ«ãƒ‰
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯FamilyActivityPickerã‚’ä½¿ç”¨
    resolve(true)
  }

  @objc
  func unshieldApps(_ resolve: @escaping RCTPromiseResolveBlock,
                    rejecter reject: @escaping RCTPromiseRejectBlock) {
    store.shield.applications = nil
    resolve(true)
  }

  @objc
  func getUsageData(_ startDate: String,
                    endDate: String,
                    resolve: @escaping RCTPromiseResolveBlock,
                    rejecter reject: @escaping RCTPromiseRejectBlock) {
    // DeviceActivity APIã§ä½¿ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    // å®Ÿè£…ã¯ ActivityReport Extension ã§è¡Œã†
    resolve([
      "totalMinutes": 45,
      "apps": [
        ["bundleId": "com.zhiliaoapp.musically", "minutes": 20],
        ["bundleId": "com.google.ios.youtube", "minutes": 15],
        ["bundleId": "com.burbn.instagram", "minutes": 10],
      ]
    ])
  }

  @objc
  static func requiresMainQueueSetup() -> Bool {
    return false
  }
}
```

```typescript
// src/native/ScreenTimeModule.ts

import { NativeModules, Platform } from 'react-native';

const { ScreenTimeModule } = NativeModules;

export type AuthorizationStatus = 'notDetermined' | 'denied' | 'approved' | 'unknown';

export interface UsageData {
  totalMinutes: number;
  apps: Array<{
    bundleId: string;
    minutes: number;
  }>;
}

class ScreenTimeService {
  async requestAuthorization(): Promise<boolean> {
    if (Platform.OS !== 'ios') {
      console.warn('Screen Time API is only available on iOS');
      return false;
    }
    return ScreenTimeModule.requestAuthorization();
  }

  async getAuthorizationStatus(): Promise<AuthorizationStatus> {
    if (Platform.OS !== 'ios') {
      return 'notDetermined';
    }
    return ScreenTimeModule.getAuthorizationStatus();
  }

  async setShieldedApps(bundleIds: string[]): Promise<boolean> {
    if (Platform.OS !== 'ios') {
      return false;
    }
    return ScreenTimeModule.setShieldedApps(bundleIds);
  }

  async unshieldApps(): Promise<boolean> {
    if (Platform.OS !== 'ios') {
      return false;
    }
    return ScreenTimeModule.unshieldApps();
  }

  async getUsageData(startDate: Date, endDate: Date): Promise<UsageData> {
    if (Platform.OS !== 'ios') {
      return { totalMinutes: 0, apps: [] };
    }
    return ScreenTimeModule.getUsageData(
      startDate.toISOString(),
      endDate.toISOString()
    );
  }
}

export const screenTimeService = new ScreenTimeService();
```

---

## èª²é‡‘ãƒ¢ãƒ‡ãƒ«

### ãƒ—ãƒ©ãƒ³æ§‹æˆ

| ãƒ—ãƒ©ãƒ³ | ä¾¡æ ¼ | æœˆé¡æ›ç®— | å‰²å¼•ç‡ |
|--------|------|----------|--------|
| **3æ—¥é–“ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«** | ç„¡æ–™ | - | - |
| **30æ—¥ãƒãƒ£ãƒ¬ãƒ³ã‚¸** | Â¥980 | Â¥980 | - |
| **90æ—¥ãƒã‚¹ã‚¿ãƒ¼** | Â¥2,350 | Â¥783 | 20%OFF |
| **å¹´é–“ãƒ—ãƒ©ãƒ³** | Â¥5,880 | Â¥490 | 50%OFF |

> **Note**: æœ‰æ–™ãƒ—ãƒ©ãƒ³é–“ã§æ©Ÿèƒ½å·®ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ã¹ã¦åŒã˜å…¨æ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚

---

## å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

### MVP (v1.0) - 2é€±é–“

| ã‚¿ã‚¹ã‚¯ | å„ªå…ˆåº¦ | å·¥æ•° | æ‹…å½“ |
|--------|--------|------|------|
| WaveAnimation ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | P0 | 2æ—¥ | - |
| IntensitySlider ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | P0 | 1æ—¥ | - |
| BreathingGuide ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | P0 | 1æ—¥ | - |
| UrgeSurfingScreen ç”»é¢ | P0 | 2æ—¥ | - |
| useStatisticsStore å®Ÿè£… | P0 | 2æ—¥ | - |
| ãƒãƒƒã‚¸ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£… | P1 | 1æ—¥ | - |
| ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”»é¢ | P1 | 2æ—¥ | - |
| Screen Timeæ¨©é™ãƒ•ãƒ­ãƒ¼ | P0 | 1æ—¥ | - |
| ãƒ†ã‚¹ãƒˆãƒ»ãƒã‚°ä¿®æ­£ | P0 | 2æ—¥ | - |

### v1.1 - è¨“ç·´ãƒ¢ãƒ¼ãƒ‰ï¼ˆ1é€±é–“ï¼‰

| ã‚¿ã‚¹ã‚¯ | å„ªå…ˆåº¦ | å·¥æ•° |
|--------|--------|------|
| MockVideoFeed ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | P0 | 2æ—¥ |
| TrainingScreen ç”»é¢ | P0 | 2æ—¥ |
| è¨“ç·´é€²æ—ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚° | P1 | 1æ—¥ |
| ãƒ†ã‚¹ãƒˆãƒ»èª¿æ•´ | P0 | 2æ—¥ |

### v1.2 - çµ±è¨ˆæ©Ÿèƒ½å¼·åŒ–ï¼ˆ1é€±é–“ï¼‰

| ã‚¿ã‚¹ã‚¯ | å„ªå…ˆåº¦ | å·¥æ•° |
|--------|--------|------|
| è©³ç´°çµ±è¨ˆç”»é¢ | P0 | 2æ—¥ |
| é€±é–“ã‚°ãƒ©ãƒ• | P1 | 1æ—¥ |
| é€±é–“ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ | P1 | 1æ—¥ |
| ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥é€£æº | P2 | 1æ—¥ |
| ãƒ†ã‚¹ãƒˆãƒ»èª¿æ•´ | P0 | 2æ—¥ |

### v1.3 - Screen Time APIçµ±åˆï¼ˆ2é€±é–“ï¼‰

| ã‚¿ã‚¹ã‚¯ | å„ªå…ˆåº¦ | å·¥æ•° |
|--------|--------|------|
| Family Controls entitlementç”³è«‹ | P0 | - |
| DeviceActivityMonitor Extension | P0 | 3æ—¥ |
| ShieldConfiguration Extension | P0 | 2æ—¥ |
| ShieldAction Extension | P0 | 2æ—¥ |
| React Native ãƒ–ãƒªãƒƒã‚¸ | P0 | 2æ—¥ |
| çµ±åˆãƒ†ã‚¹ãƒˆ | P0 | 3æ—¥ |

---

## å‚è€ƒæ–‡çŒ®

1. Gollwitzer, P. M. (1999). Implementation intentions: Strong effects of simple plans. American Psychologist.
2. Marlatt, G. A. & Gordon, J. R. (1985). Relapse Prevention. Guilford Press.
3. Bowen, S., et al. (2009). Mindfulness-Based Relapse Prevention for Substance Use Disorders. Cognitive and Behavioral Practice.
4. Lally, P. et al. (2010). How are habits formed. European Journal of Social Psychology.
5. Kahneman, D. (2011). Thinking, Fast and Slow. Farrar, Straus and Giroux.

---

## å¤‰æ›´å±¥æ­´

| æ—¥ä»˜ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | å¤‰æ›´å†…å®¹ |
|------|-----------|----------|
| 2025-12-20 | 1.0 | åˆç‰ˆä½œæˆ |
| 2025-12-20 | 1.1 | ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®šã€èª²é‡‘ãƒ¢ãƒ‡ãƒ«è¿½åŠ  |
| 2025-12-20 | 2.0 | ç¿’æ…£å½¢æˆãƒ„ãƒ¼ãƒ«ã‚­ãƒƒãƒˆã€çµ±è¨ˆæ©Ÿèƒ½ã€ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ  |
| 2025-12-20 | 2.1 | æ©Ÿèƒ½ã‚’çµã‚Šè¾¼ã¿ã€‚æ ¸å¿ƒæ‰‹æ³•ã¨ã—ã¦ã€Œè¡å‹•ã‚µãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã€ã‚’æ¡ç”¨ |
| 2025-12-20 | 3.0 | è©³ç´°å®Ÿè£…è¨ˆç”»ã‚’è¿½åŠ ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆã€TypeScriptå‹å®šç¾©ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä»•æ§˜ã€å·¥æ•°è¦‹ç©ã‚‚ã‚Šã‚’è¨˜è¼‰ |

